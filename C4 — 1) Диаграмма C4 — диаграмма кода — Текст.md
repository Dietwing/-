# C4 Level 4 (Code)

Ниже приведено развернутое описание трёх диаграмм уровня **C4 Level 4 (Code)**.  
На данном уровне мы фиксируем **структуру кода** и **направления зависимостей**: какие классы являются сущностями предметной области, какие — прикладными сервисами, где проходит граница транзакций, и как реализован офлайн-обмен файлами (импорт/экспорт).

---

## 1) Domain Core (Code): Characters, Combat, Rules, Override, Events

### 1.1. Что именно показывает диаграмма

Диаграмма раскрывает кодовую модель контейнера **Domain Core** и демонстрирует, что внутри него выделены несколько смысловых групп:

- **Entities / Aggregates**: персонажи, NPC, характеристики, ресурсы, эффекты;
- **Combat Model**: структура боевого столкновения и порядок ходов;
- **Rules / Actions**: движок правил и команда действия;
- **Calculation**: вычисление последствий (урон, модификаторы);
- **Dice Facade**: фасад бросков и абстракция RNG;
- **Manual Override**: легализованное ручное вмешательство мастера;
- **Validation**: контроль корректности доменных изменений;
- **Domain Events**: события, фиксирующие происходящее.

То есть Domain Core в данной схеме — это не “просто набор классов”, а связанная система, где поведение строится вокруг правил, событий и контрольных проверок.

---

### 1.2. Сущности персонажа: Character, NPC, Stats, Resources

**Character** — ключевая доменная сущность, которая хранит:
- идентификатор и имя;
- **Stats** (карта значений по ключам StatKey);
- **Resources** (HP и иные ресурсы);
- активные эффекты (EffectInstance).

При этом Character содержит методы изменения состояния (`applyDamage`, `heal`, `setStat`, `addEffect`, `removeEffect`), то есть **изменения происходят через поведение**, а не “прямой доступ к полям”.

**NPC** по структуре близок к Character, но добавляет признак архетипа (`archetype`), что удобно для правил и сценариев.

**Stats** и **Resources** выделены отдельно, чтобы:
- не смешивать “характеристики” и “ресурсы” в одной структуре;
- обеспечить единый, контролируемый API работы с числовыми параметрами.

---

### 1.3. Эффекты: Definition vs Instance

Эффект разделён на:

- **EffectDefinition** (описание эффекта) — “что это за эффект вообще”  
  (id, name, durationPolicy, modifiers).
- **EffectInstance** (экземпляр эффекта) — “как он применён сейчас”  
  (instanceId, definitionId, source, expiresAtRound, stacks).

Это позволяет:
- хранить “справочник” эффектов отдельно,
- сериализовать текущее состояние (кто чем усилен и до какого раунда),
- корректно поддерживать стаки и срок действия.

---

### 1.4. Модель боя: Encounter и порядок ходов

**Encounter** — агрегат боя:
- список участников (`ParticipantRef`);
- `TurnOrder` (порядок ходов);
- `CombatState` (NOT_STARTED / IN_PROGRESS / FINISHED);
- текущий раунд.

**ParticipantRef** унифицирует ссылки на участника (Character или NPC) через `ParticipantKind`.  
Это полезно, потому что боевой модуль не обязан знать “конкретный класс”, а оперирует ссылками на сущности.

**TurnOrder / TurnEntry** задают механику инициативы и текущего активного участника.

---

### 1.5. RulesEngine и команда действия

**RulesEngine** выступает как “механический центр”:
- сначала `validate(...)` проверяет, допустимо ли действие;
- затем `apply(...)` применяет действие и возвращает **ActionResult**.

**ActionCommand** описывает действие абстрактно:
- actor,
- ActionType (ATTACK / CAST / USE_ITEM / DEFEND / MOVE / CUSTOM),
- payload (параметры).

**ActionResult** содержит:
- список **DomainEvent** (что произошло как событие),
- список **StateChange** (человекочитаемое описание изменений).

Вследствие этого RulesEngine не просто “меняет HP”, а возвращает структурированный результат, пригодный для журнала, UI и анализа.

---

### 1.6. Расчёты и броски (Calculator + DiceFacade)

**InteractionCalculator** отвечает за вычисления последствий:
- урон,
- модификаторы,
- итоговые значения на основе контекста и результата броска.

**DiceFacade** — единая точка бросков, которая использует абстракцию **IRng**.  
Интерфейс IRng позволяет:
- подменять RNG в тестах,
- контролировать диапазоны,
- не привязывать Domain Core к конкретной реализации генератора.

---

### 1.7. Manual Override: StatOverrideService как “легальная ручная правка”

**StatOverrideService** вводит ключевой для проекта механизм:  
ручные изменения мастером представлены отдельным сервисом, который:

- меняет HP/статы/эффекты *по причине (reason)*;
- возвращает **DomainEvent**, фиксирующее факт вмешательства.

Это важно, потому что:
- ручная правка не маскируется под “обычный расчёт механики”;
- в журнале всегда остаётся след “почему и что изменено”;
- Validator может не допустить некорректные значения даже при ручном вводе.

Отдельно показана опциональная связь с Encounter (combat context), поскольку ручная правка может учитывать, что изменения были внесены “в рамках боя”.

---

### 1.8. Validator и Domain Events

**Validator** — “охранный механизм” Domain Core:
- проверка HP,
- проверка значений статов,
- проверка корректности действия в контексте.

**DomainEvent** — абстрактная база событий, от которой наследуются:
- ActionPerformedEvent,
- DamageAppliedEvent,
- RoundEndedEvent,
- StatManuallyAdjustedEvent.

Наличие `StatManuallyAdjustedEvent` отдельно подчёркивает, что override — полноценная часть доменной модели.

---

## 2) Application Services (Code): Use Cases, Roles, Transactions

### 2.1. Общий смысл диаграммы

Диаграмма показывает, как организован код контейнера **Application Services**, то есть прикладного слоя, который:

- принимает запрос от UI,
- проверяет роль пользователя,
- выполняет действие в транзакции,
- вызывает доменные сервисы,
- сохраняет изменения и пишет события в лог.

Иными словами, здесь концентрируется “управленческая логика” (оркестрация), а не механика.

---

### 2.2. Контроль ролей

**UserRole** задаёт две роли:
- PLAYER
- GM

**RoleGuard** обеспечивает централизованную проверку:  
`assertAllowed(role, action)`, чтобы мастерские сценарии не становились доступны игроку.

---

### 2.3. Транзакции

**IUnitOfWork** задаёт основу транзакционной дисциплины: begin / commit / rollback.  
**TransactionManager** запускает действия в транзакционной рамке (`runInTx(action)`).

Это особенно важно для:
- обработки хода боя,
- ручных правок,
- импорта персонажей,
- операций с заметками.

---

### 2.4. Репозитории как граница Persistence

Интерфейсы репозиториев показывают, что Application Services не привязан к формату хранения:

- CharacterRepository
- EncounterRepository
- NotesRepository
- SessionLogRepository

Тем самым сохраняется возможность хранить данные в JSON/SQLite без изменения прикладных сценариев.

---

### 2.5. Доменные фасады внутри Application Services

**CombatService** связывает:
- RulesEngine (домен),
- EncounterRepository (состояние боя),
- SessionLogRepository (лог событий).

**ManualAdjustService** связывает:
- StatOverrideService (доменный override),
- CharacterRepository,
- SessionLogRepository.

То есть фасады делают “мост” между доменной логикой и хранилищем/журналом.

---

### 2.6. Use Cases и их обязанности

- **RunCombatUC**: (роль + транзакция + CombatService) → ActionResult  
- **ManualAdjustStatsUC**: (роль + транзакция + ManualAdjustService) → изменения с reason  
- **ImportCharacterUC**: (роль + транзакция + ImportService + CharacterRepository) → UUID  
- **CreateSheetUC**: (роль + транзакция + CharacterRepository) → UUID  
- **RulesAccessUC**: (роль + RulesIndex) → результаты поиска  
- **NotesUC**: (роль + транзакция + NotesRepository) → CRUD заметок

Важная деталь: ручные правки выделены в отдельный UC, что соответствует компонентному уровню (Level 3) и не смешивает “бой” с “вмешательством мастера”.

---

## 3) Import/Export (Code): JSON Schema, Versioning, Validation, Errors

### 3.1. Что показывает диаграмма

Диаграмма раскрывает код контейнера **Import/Export**, предназначенного для офлайн-обмена листами:

- экспорт персонажа в файл (JSON и опционально PDF),
- импорт файла обратно в систему,
- поддержка версии схемы,
- валидация,
- перевод ошибок в понятный формат.

---

### 3.2. Экспорт: ExportService

**ExportService** использует:
- JsonSerializer — кодирование DTO в bytes,
- SchemaVersioning — проставление версии,
- FileValidator — контроль корректности DTO,
- PdfGenerator — опциональная печать.

Методы:
- `exportCharacter(c): Bytes`
- `exportPdf(c): Bytes`

Смысл: экспорт формирует **стабильный переносимый формат**, который можно передать мастеру любым каналом.

---

### 3.3. Импорт: ImportService

**ImportService** использует:
- JsonSerializer — decode в DTO,
- SchemaVersioning — проверка версии и миграция,
- FileValidator — проверка структуры,
- ErrorMapper — человекочитаемые сообщения.

Метод:
- `importFile(file): Character`

То есть импорт — это цепочка “decode → versioning → validate → сборка доменной модели”.

---

### 3.4. DTO файла и метаданные

**CharacterFileDTO** включает:
- **FileMetaDTO** (schemaVersion, exportedAt, appId),
- **CharacterSheetDTO** (содержимое листа).

**CharacterSheetDTO** содержит:
- имя,
- stats,
- hpCurrent/hpMax,
- список EffectDTO.

Такое разделение нужно, чтобы:
- версия схемы была всегда рядом с данными,
- можно было мигрировать формат независимо от доменных классов.

---

### 3.5. Версионирование и миграции

**SchemaVersioning** выполняет:
- получение текущей версии,
- проверку поддержки (`ensureSupported`),
- миграцию (`migrate`) старых DTO к актуальному формату.

Это ключевой механизм, потому что обмен файлами в офлайн-сценарии почти неизбежно приводит к ситуации “у игрока одна версия приложения, у мастера другая”.

---

### 3.6. Валидация и ошибки

**FileValidator** проверяет DTO и возвращает ValidationResult (ok + errors).  
**ErrorMapper** преобразует исключения/ошибки в понятные сообщения для UI.

Тем самым пользователь получает не “stack trace”, а конкретный смысл:  
какое поле отсутствует, какая версия не поддерживается, что именно нужно поправить.

---

### 3.7. Сохранение в библиотеку: ImportToLibraryAdapter

**ImportToLibraryAdapter** показывает, как импортированный Character попадает в Persistence:
- принимает CharacterRepository,
- выполняет upsert,
- возвращает UUID.

ImportService опционально вызывает этот адаптер **после успешного импорта**, но чаще это будет инициировано на уровне Use Case (как и указано в диаграмме).

---

## Общий вывод по трём диаграммам

На уровне кода видно, что архитектура выдерживает единый принцип:

- Domain Core отвечает за механику и события;
- Application Services управляет сценариями, ролями и транзакциями;
- Import/Export обеспечивает офлайн-обмен с версиями, валидностью и понятными ошибками.

При этом ручная правка мастером:
- оформлена отдельным сервисом и отдельным UC,
- фиксируется событием,
- не разрушает консистентность данных за счёт Validator и журналирования.
