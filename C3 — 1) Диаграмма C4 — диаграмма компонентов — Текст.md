# C4 Level 3: Диаграммы компонентов (Components)

В данном разделе приведены пояснения к двум диаграммам уровня **C4 Level 3 (Component Diagram)**.  
Если на уровне контейнеров (Level 2) мы фиксировали крупные подсистемы приложения, то на уровне компонентов мы **раскрываем внутреннее устройство отдельных контейнеров** — то есть показываем, какие логические компоненты “живут внутри” и как они организуют потоки данных и ответственности.

Рассматриваются два контейнера:
1. **Domain Core** — ядро предметной области (персонажи, бой, события).
2. **Import / Export** — обмен листами и импорт персонажей в библиотеку мастера.

---

## 1) C4 Level 3 — Components: Domain Core (персонажи / бой / события)

### 1.1 Назначение диаграммы

Данная диаграмма уточняет внутреннюю структуру контейнера **Domain Core** — именно той части системы, где сосредоточена основная логика НРИ:  
персонажи и NPC, боевые столкновения, правила действий, расчёты эффектов и событийная модель.

Смысл такого разбиения заключается в том, чтобы:
- отделить устойчивые сущности предметной области от вспомогательных механизмов;
- упорядочить взаимосвязи “правила → расчёты → изменения характеристик”;
- зафиксировать единый подход к броскам (через фасад) и к фиксации происходящего (через события).

---

### 1.2 Компоненты внутри Domain Core и их роль

**Character Model**
- содержит сущности персонажа и NPC, их характеристики, модификаторы, состояния;
- выступает “опорной моделью” для всех дальнейших расчётов и эффектов.

**Combat Model**
- описывает структуру боя: Encounter, TurnOrder, текущее состояние, этапы раунда;
- задаёт контекст, в котором применяются правила и происходят события.

**Rules Engine**
- компонент, который “интерпретирует” правила действий: проверки, ограничения, эффекты;
- принимает действие и переводит его в набор проверок и последствий.

**Interaction Calculator**
- отвечает за прикладные расчёты: урон, эффекты, бонусы/штрафы, итоговые значения;
- превращает “правило” в конкретные числа и изменения состояния.

**Dice Facade**
- единая точка доступа к броскам;
- вынесен в отдельный компонент, чтобы доменная логика не зависела от конкретного способа генерации случайности.

**Validation**
- проверка корректности данных: диапазоны значений, обязательные поля, целостность состояния;
- используется для того, чтобы доменная модель оставалась консистентной.

**Domain Events**
- модель доменных событий (ActionPerformed, DamageApplied, RoundEnded и т. п.);
- фиксирует “что произошло” в доменной системе и обеспечивает удобную связность с журналированием и UI на более высоком уровне.

---

### 1.3 Связи и логика взаимодействия (как “течёт” обработка)

На диаграмме показан характерный порядок работы доменной части:

- `Character Model → Validation`  
  Характеристики и параметры персонажей проверяются на корректность.

- `Combat Model → Rules Engine`  
  В рамках конкретного столкновения Rules Engine применяет правила действий.

- `Rules Engine → Interaction Calculator`  
  Правило переводится в вычисление результата: урон, эффект, модификаторы.

- `Interaction Calculator → Character Model`  
  Результаты расчётов отражаются на состоянии персонажа (HP, эффекты, статусы).

- `Combat Model → Domain Events` и `Rules Engine → Domain Events`  
  Бой и действия порождают события, которые можно логировать и отображать в UI.

- `Rules Engine → Dice Facade → Dice/RNG`  
  Rules Engine запрашивает бросок через фасад, а фасад уже вызывает контейнер RNG (внешнюю зависимость относительно Domain Core).

---

### 1.4 Итог по Domain Core

Эта декомпозиция показывает, что доменная часть устроена как связка:

- **модель состояния** (Character + Combat),
- **механизм принятия решений** (Rules Engine),
- **механизм вычисления последствий** (Calculator),
- **унифицированная случайность** (Dice Facade),
- **контроль корректности** (Validation),
- **фиксация происходящего** (Domain Events).

Вследствие этого Domain Core остаётся устойчивым при изменениях UI или форматов хранения данных.

---

## 2) C4 Level 3 — Components: Import/Export (лист игрока → библиотека мастера)

### 2.1 Назначение диаграммы

Вторая диаграмма раскрывает контейнер **Import / Export**, который отвечает за жизненно важный для офлайн-проекта процесс:

- игрок создаёт лист и выгружает его в файл;
- файл передаётся мастеру через внешний канал (мессенджер/почта/флешка);
- мастер импортирует файл в свою библиотеку персонажей.

Особенность офлайн-сценария в том, что модуль Import/Export должен быть “прочным”:  
он обязан корректно обрабатывать несовпадения версий, ошибки структуры и неполные данные, при этом возвращая понятные сообщения для пользователя.

---

### 2.2 Компоненты внутри Import/Export и их роль

**Export Service**
- готовит данные к выгрузке: собирает нужные поля, формирует структуру;
- инициируется командой из Application Services.

**Import Service**
- принимает файл, выполняет загрузку, преобразует в доменную модель и сохраняет;
- выступает центральной точкой импорта.

**Serializer**
- отвечает за JSON encode/decode;
- вынесен отдельно, чтобы логика экспорта/импорта не была “перемешана” с техническими деталями сериализации.

**Schema Versioning**
- ведёт версию схемы файла;
- обеспечивает миграции формата (когда приложение обновилось, а файл старый).

**File Validator**
- проверяет структуру файла: обязательные поля, типы, соответствие схемам;
- формирует “жёсткую” гарантию, что на импорт попадут только корректные данные.

**PDF Generator (опционально)**
- создаёт печатное/просмотровое представление (если нужно);
- влияет только на экспортную ветку.

**Error Mapper**
- переводит технические ошибки импорта в человекочитаемые сообщения для UI;
- важен для того, чтобы пользователь понимал, что исправлять.

---

### 2.3 Связи и логика взаимодействия (экспорт и импорт)

#### Экспорт (из системы наружу)
- `Application Services → Export Service`  
  Вызывается сценарий выгрузки.

- `Export Service → Serializer`  
  Подготовленные данные сериализуются в JSON.

- `Export Service → Schema Versioning`  
  Проставляется версия схемы (для совместимости).

- `Export Service → PDF Generator (опционально)`  
  Генерируется PDF-вид листа, если он нужен пользователю.

- `Export Service → Канал передачи файла`  
  Итоговый файл выходит во внешнюю среду.

#### Импорт (из внешней среды в систему)
- `Канал передачи файла → Import Service`  
  В систему поступает файл от игрока.

- `Import Service → File Validator`  
  Сначала выполняется проверка корректности.

- `File Validator → Schema Versioning`  
  Проверяется версия и, при необходимости, выполняется миграция/приведение формата.

- `Import Service → Serializer`  
  Происходит десериализация JSON в структуру данных.

- `Import Service → Domain Core`  
  Данные собираются в доменную модель (персонаж/NPC) и становятся полноценной частью предметной области.

- `Import Service → Persistence`  
  Сохранение в локальное хранилище (библиотека мастера).

- `Import Service → Error Mapper`  
  Ошибки превращаются в понятные сообщения для UI (что именно не так и почему).

---

### 2.4 Итог по Import/Export

Диаграмма показывает, что модуль обмена данными построен не “одним куском”, а как цепочка специализированных компонентов:

- экспорт отделён от импорта,
- сериализация вынесена отдельно,
- совместимость поддерживается версионированием схем,
- корректность контролируется валидатором,
- пользователь получает понятные ошибки через Error Mapper.

В результате импорт/экспорт становится устойчивым и пригодным для реального офлайн-использования, когда файлы могут перемещаться между устройствами и версиями приложения.

---

## Общий вывод по двум диаграммам

Обе диаграммы (Domain Core и Import/Export) демонстрируют один и тот же архитектурный принцип проекта:  
**сложная логика разбивается на компоненты с чёткими зонами ответственности**, а зависимости направлены так, чтобы ядро предметной области не “протекало” техническими деталями.

- В Domain Core основной упор сделан на устойчивую предметную модель и событийность.
- В Import/Export — на совместимость, проверку данных и понятную обработку ошибок.

Это даёт основу для дальнейшего уточнения: либо через детальные UML-диаграммы (классы/последовательности), либо через описание конкретных use-case сценариев.
