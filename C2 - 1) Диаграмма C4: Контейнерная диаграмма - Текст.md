# C4: Контейнерная диаграмма — «НРИ-Помощник (офлайн)» (Level 2)

Ниже приведено пояснение **контейнерной диаграммы (C4 Level 2)** для проекта **«НРИ-Помощник (офлайн)»**.  
Если контекстная диаграмма показывала систему “снаружи”, то контейнерная диаграмма уточняет, **из каких крупных частей (контейнеров) состоит приложение**, как они распределяют ответственность и как организованы основные потоки данных.

---

## 1) Назначение контейнерной диаграммы

Контейнерная диаграмма отвечает на вопрос:  
**«Какие крупные подсистемы внутри приложения обеспечивают его работу и как они взаимодействуют?»**

При этом под *контейнером* здесь понимается не Docker-контейнер, а логически выделяемый “крупный блок” системы: слой UI, прикладные сценарии, доменная часть, подсистемы импорта/экспорта, хранения данных и т. п.

Вследствие этого данная диаграмма выступает мостом между:
- **общим пониманием ролей пользователей** (Level 1),
- и **детальной декомпозицией модулей** (Level 3 — компоненты).

---

## 2) Граница системы и внешняя среда

### Граница системы
Пунктирная рамка **«НРИ-Помощник (офлайн)»** отделяет то, что является частью приложения, от внешних объектов.

Внутри границы находятся основные контейнеры, которые совместно образуют единый офлайн-продукт.

### Внешняя среда (вне ответственности приложения)
Вынесены три внешних элемента:

- **Локальная файловая система (JSON / SQLite)** — физическое место хранения данных.
- **Материалы правил (книги, файлы)** — источник контента справочника правил.
- **Канал передачи файла (мессенджер и т. п.)** — реальный путь передачи экспортированного листа персонажа между участниками.

Таким образом, приложение не управляет этими объектами напрямую, но регулярно с ними взаимодействует через свои контейнеры.

---

## 3) Пользователи (акторы)

На диаграмме сохранены две ключевые роли, сформированные в рамках концепции проекта:

### Игрок — `P`
Использует приложение ограниченно:
- создаёт лист персонажа,
- экспортирует файл для передачи мастеру.

### Гейммастер — `GM`
Использует приложение как рабочий инструмент ведения сессии:
- управляет процессом игры,
- работает с боем, правилами, заметками,
- импортирует листы персонажей в библиотеку.

Иными словами, на уровне контейнеров роли остаются теми же, но теперь видно, **через какие части приложения** каждая роль взаимодействует с системой.

---

## 4) Контейнеры внутри системы и их ответственность

Ниже — пояснение каждого контейнера внутри границы системы.

### 4.1 UI (Desktop)
**Назначение:** пользовательский интерфейс в виде окон/форм.  
UI — это “точка контакта” для обоих пользователей (и игрока, и мастера), при этом:
- UI не хранит бизнес-логику;
- UI передаёт действия в прикладной слой (use cases).

**Связи на диаграмме:**
- `P → UI` — создание листа
- `GM → UI` — управление игрой
- `UI → Application Services` — передача действий пользователя

---

### 4.2 Application Services (Use Cases)
**Назначение:** слой прикладных сценариев — то, что обычно называют “сервисами приложения” или “use-case-логикой”.

Задача этого контейнера — **связать интерфейс с доменом**:
- принять команду пользователя (создать персонажа, провести ход боя, импортировать лист, добавить заметку);
- вызвать нужные операции доменной части;
- организовать доступ к правилам, блокноту, хранилищу, импорту/экспорту.

**Связи на диаграмме:**
- `UI → APP` — действия пользователя
- `APP → Domain Core` — вызов доменной логики
- `APP → Rules / Notebook / ImportExport / Persistence` — задействование вспомогательных подсистем

---

### 4.3 Domain Core (ядро предметной области)
**Назначение:** центральная предметная логика проекта.  
Здесь находятся основные сущности и правила предметной области НРИ:

- персонажи и NPC,
- характеристики и их вычисления,
- боевые сущности и состояние боя,
- игровые события (логика “что произошло” и “к чему это привело”).

Domain Core — это та часть, которая должна оставаться устойчивой при изменениях UI или способа хранения.

**Связи на диаграмме:**
- `APP → DOMAIN` — применение предметной логики
- `DOMAIN → RNG` — запрос случайности для механик

---

### 4.4 Dice / RNG (броски кубов и случайность)
**Назначение:** единый механизм случайности (генератор бросков, проверки, вероятностные события).

Он выделен отдельно, чтобы:
- не “размазывать” генерацию случайности по всему домену;
- обеспечить единый подход к логированию бросков, повторяемости, настройкам (если они появятся).

**Связи на диаграмме:**
- `DOMAIN → RNG` — доменная логика использует броски кубов

---

### 4.5 Rules Reference (справочник правил)
**Назначение:** поиск и просмотр правил (как контента).

Важный момент: правила могут быть представлены как:
- локальные файлы,
- структурированный справочник,
- ссылки на фрагменты из книг (как контент проекта).

Диаграмма показывает, что контейнер `Rules Reference` читает контент из внешнего источника.

**Связи на диаграмме:**
- `APP → RULES` — запрос “показать правило”
- `RULES → RM` — чтение материалов правил

---

### 4.6 Notebook (заметки)
**Назначение:** рабочий блокнот мастера:
- заметки по сессии,
- идеи по кампании,
- фиксация событий и важных деталей.

`Notebook` выделен отдельно, потому что заметки — самостоятельный функциональный блок, которым гейммастер пользуется постоянно и который требует сохранения/поиска.

**Связи на диаграмме:**
- `APP → NOTES` — операции “создать/изменить/просмотреть заметки”

---

### 4.7 Import / Export (обмен листами и выгрузка)
**Назначение:** экспорт листа персонажа и импорт персонажей в библиотеку мастера.

На уровне контейнеров фиксируется важная идея офлайн-проекта:
- система выгружает данные в переносимый файл (например, JSON/PDF),
- затем файл передаётся внешним каналом (мессенджер/почта/флешка),
- после чего мастер может выполнить импорт.

**Связи на диаграмме:**
- `APP → IEX` — команды экспорта/импорта
- `IEX → CH` — передача файла через внешний канал

---

### 4.8 Persistence (работа с данными и хранилищем)
**Назначение:** слой сохранения и загрузки данных приложения.

Важно, что доменная логика не “общается” с файлами напрямую — этим занимается `Persistence`, что:
- упрощает тестирование;
- удерживает единый подход к работе с данными;
- позволяет выбирать формат хранения (JSON/SQLite) без переработки всей системы.

**Связи на диаграмме:**
- `APP → PERSIST` — сохранить/загрузить
- `PERSIST → FS` — фактическое хранение в JSON/SQLite

---

## 5) Основные потоки (как “ходит” работа)

Чтобы связать контейнеры в целостную картину, удобно выделить два типичных потока.

### Поток A: Игрок создаёт персонажа и передаёт лист мастеру
1. `P → UI` — пользователь заполняет форму листа.
2. `UI → APP` — UI отправляет команды в use cases.
3. `APP → DOMAIN` — доменная часть считает характеристики и валидирует модель персонажа.
4. `APP → IEX` — экспорт листа.
5. `IEX → CH` — файл передаётся через внешний канал (мессенджер и т. п.).
6. `CH → GM` — мастер получает файл (это уже отражалось на Level 1).

### Поток B: Мастер ведёт сессию и бой
1. `GM → UI` — мастер управляет сценой/боем.
2. `UI → APP` — команды сценариев.
3. `APP → DOMAIN` — изменение состояния боя/событий.
4. `DOMAIN → RNG` — броски, проверки, случайные эффекты.
5. `APP → NOTES / RULES` — в процессе игры мастер открывает правила и ведёт заметки.
6. `APP → PERSIST → FS` — сохранение данных сессии/кампании.

---

## 6) Итоговая интерпретация

Контейнерная диаграмма фиксирует ключевую архитектурную идею проекта:

- приложение является **офлайн-системой**, в которой данные хранятся локально (JSON/SQLite);
- взаимодействие строится вокруг **двух ролей** с разной глубиной доступа (игрок/мастер);
- ядро предметной логики (**Domain Core**) отделено от UI и хранения данных;
- случайность (**Dice/RNG**) выделена как самостоятельная подсистема;
- обмен листами персонажей организован через **Import/Export** и внешний канал передачи файла;
- правила и заметки существуют как самостоятельные функциональные контейнеры, которыми мастер пользуется “в процессе”.

Такой уровень детализации подготавливает переход к следующему шагу — **Component Diagram (Level 3)**, где уже можно раскрывать внутреннюю структуру контейнеров (например, какие компоненты входят в Domain Core и как устроены use cases).
