1. Общее описание C4-подхода

Архитектура приложения представлена через последовательную модель C4.
Такой подход позволяет раскрывать систему постепенно — от общего представления к техническим деталям.
Каждый уровень фиксирует свой аспект:

Уровень	Вопрос	Смысл
Context	«Что это за система?»	Роли, границы, взаимодействия
Container	«Из каких частей она состоит?»	Основные подсистемы и их связи
Component	«Как устроены эти части?»	Внутренняя организация логики
Code	«Как представлены данные?»	Классы, модели, связи

В моём проекте такая структура позволяет показать развитие архитектуры от общего замысла до внутреннего устройства механик.

2. Контекстная диаграмма (Context)

Файл: context.puml

Контекстный уровень даёт самое широкое представление о системе — кто с ней работает и какие информационные потоки возникают.

Основные участники:

Ведущий (Мастер) — управляет игровой сессией, вводит данные, формирует отчёты.

Игрок — передаёт информацию о персонаже, взаимодействует через ведущего.

Система «НРИ-Помощник (офлайн)» — приложение, которое выполняет расчёты, обрабатывает события, ведёт журнал и экспортирует данные.

Особенности:

система полностью автономна (без сети);

игроки взаимодействуют через мастера, не напрямую;

приложение выступает единым центром управления игровой логикой.

Диаграмма задаёт внешние границы проекта и позволяет сразу понять его назначение.

Назначение контекстной диаграммы:
Обозначить роль системы, её пользователей и способы взаимодействия.

3. Контейнерная диаграмма (Container)

Файл: container.puml

На этом уровне архитектура раскрывается детальнее: какие крупные подсистемы образуют приложение.

Состав контейнеров:

1) Интерфейс (UI)

формы персонажей;

панели управления боем и сценами;

просмотр отчётов и журналов.

2) Ядро (Core / App Logic)

обработка бросков;

механика боевых расчётов;

работа с состояниями и эффектами;

ведение журналов событий.

3) Локальное хранилище (SQLite / Files)

данные персонажей;

сохранённые сессии;

события;

резервные копии.

Связи:

UI → Core: передача команд и действий.

Core ↔ Storage: чтение/запись данных.

Ведущий ↔ UI: центральная точка управления.

Контейнерная диаграмма фиксирует автономность приложения и чёткое разделение обязанностей между интерфейсом, бизнес-логикой и данными.

Назначение:
Показать общую конструкцию приложения и распределение ответственности между крупными частями.

4. Компонентная диаграмма ядра (Component)

Файл: component-core.puml

Этот уровень раскрывает внутреннюю организацию контейнера Core.
Он показывает, какие модули обеспечивают игровую механику.

Основные компоненты:

CharacterEditor — редактирование персонажей, атрибутов, навыков, эффектов, инвентаря.

DiceEngine — система бросков кубиков и модификаторов.

CombatEngine — боевая логика: инициатива, урон, состояния.

Journal — ведение лога действий, фиксация событий.

StorageService — взаимодействие с локальным хранилищем.

Reports — экспорт итогов и отчётов (PDF/CSV).

Взаимосвязи модулей:

DiceEngine передаёт результаты в CombatEngine.

CharacterEditor и CombatEngine используют Journal для записи ключевых событий.

Reports собирает данные через StorageService.

Логика модулей разделена, но взаимодействие между ними строгов выстроено.

Компонентная модель даёт структурированное понимание внутренних механизмов системы и путей расширения функционала.

Назначение:
Описать детальную структуру ядра и разграничение логики внутри приложения.

5. Диаграмма кода (Code)

Файл: code-character.puml

На кодовом уровне представлены конкретные сущности данных, используемых системой.
Это уже не архитектурная абстракция, а рабочая модель, по которой строится приложение.

Главные классы:
Character

id

name

набор атрибутов

навыки

активные эффекты

инвентарь

методы модификации состояния

Effect

название

модификаторы

длительность

влияние на персонажа

Item

идентификатор

описание

свойства предмета

Связи:

Персонаж содержит множество эффектов и предметов.

Эффекты и предметы — составные элементы, не существуют отдельно.

Такой уровень диаграммы помогает заранее продумать структуру данных и избежать хаоса при реализации.

Назначение:
Формализовать структуру данных, чтобы код был согласованным и расширяемым.
