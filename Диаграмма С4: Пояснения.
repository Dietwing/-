1. Общая логика применения C4-модели

C4-подход используется для структурного описания программных систем, последовательно переходя от общего вида к техническим деталям. Он позволяет выстроить архитектурное представление так, чтобы любую часть можно было осмыслить независимо от уровня подготовки читателя — от руководителя проекта до разработчика.

Структура уровней:

Контекст (Context) — что представляет собой система, где её границы и кто с ней взаимодействует.

Контейнеры (Container) — из каких крупных частей она состоит и как эти части связаны.

Компоненты (Component) — внутренняя структура отдельных контейнеров.

Код (Code) — уровень моделей и классов, на основе которых система функционирует.

В моём проекте все четыре уровня используются для формирования целостной картины того, как построено офлайн-приложение для НРИ. Ниже — подробное пояснение каждого файла диаграмм.

2. Контекстная диаграмма

Файл: context.puml

Что показывает

Контекстная диаграмма — самый «широкий» и абстрактный взгляд на систему. Она отвечает на вопрос:
«Что это за приложение, кто с ним работает и какие информационные потоки возникают?»

В моей системе определены две основные роли:

Ведущий (Мастер) — создаёт игровую сессию, управляет механиками, отслеживает события, формирует отчёты.

Игрок — передаёт мастеру данные персонажа и получает результаты действий (через интерфейс ведущего).

Сама система представлена как единый офлайн-модуль:

НРИ-Помощник (офлайн) — приложение, выполняющее обработку механик, расчёты, ведение журналов и экспорт данных.

Ключевые моменты

Взаимодействие построено точка-к-точке без сети.

Игрок взаимодействует с системой через мастера, а не напрямую.

Система показана как замкнутый контур: внешних интеграций нет, зависимостей нет.

Зачем нужна эта диаграмма

Она задаёт границы проекта.
Это фундамент для дипломной части по архитектуре — читатель сразу понимает:

где проходит линия взаимодействия,

какие роли имеют отношение к системе,

какие задачи каждый участник решает внутри игрового процесса.

3. Контейнерная диаграмма

Файл: container.puml

Что показывает

Контейнерная диаграмма углубляется на следующий уровень и описывает внутреннее устройство приложения. Она отвечает на вопрос:
«Из каких крупных модулей состоит программа и как они связываются между собой?»

В системе выделены следующие контейнеры:

UI (Desktop UI)
Интерфейс, через который мастер управляет сессией, вносит данные, просматривает отчёты.

Core (App Logic)
Сердцевина программы: обработка бросков, боевых расчётов, эффектов, состояний, журналов.

Local Storage (SQLite / Files)
Локальная база данных и файловые структуры, где хранятся персонажи, события, сессии и бэкапы.

Основные связи

UI передаёт команды в Core.

Core сохраняет и читает данные из локального хранилища.

Ведущий взаимодействует только с UI.

Ключевые особенности

Приложение работает полностью автономно, без удалённых запросов.

Архитектура разделена по принципу:
Интерфейс → Логика → Хранилище
что заметно упрощает расширение функционала.

Зачем нужна диаграмма

Она показывает архитектурную структуру приложения — то, насколько чётко разделены зоны ответственности, как реализована автономность и как обеспечивается устойчивость работы.

4. Компонентная диаграмма Core

Файл: component-core.puml

Что показывает

Эта диаграмма погружается в контейнер Core и описывает его внутренние модули. Она отвечает на вопрос:
«Как распределена логика игры внутри основного ядра?»

Среди ключевых компонентов выделены:

CharacterEditor — редактирование персонажей (атрибуты, навыки, эффекты, инвентарь).

DiceEngine — система бросков и модификаторов.

CombatEngine — боевая логика, инициатива, урон, состояния.

Journal — ведение лога событий.

StorageService — доступ к данным и резервным копиям.

Reports — генерация отчётов по сессиям.

Взаимодействия

DiceEngine работает вместе с CombatEngine, передавая результаты бросков.

CharacterEditor и CombatEngine записывают данные в Journal.

Reports строит отчёты на основе данных из StorageService.

Что важно

Компоненты независимы и могут развиваться отдельно.
Такое разделение облегчает масштабируемость: можно добавлять новые механики, не затрагивая существующие.

Зачем нужна диаграмма

Она раскрывает внутреннюю структуру логики приложения — это полезно:

для диплома (обоснование архитектурных решений),

для ревью, если проект будет расширяться,

для документирования, чтобы самому не запутаться через год.

5. Диаграмма кода (модель Character)

Файл: code-character.puml

Что показывает

Этот уровень демонстрирует уже конкретные классы и сущности, на которых строится модель данных.

Основные классы:

Character — сущность персонажа.

Effect — эффекты, влияющие на характеристики.

Item — предметы инвентаря.

Показаны атрибуты (имя, характеристики, навыки, список эффектов) и базовые методы (applyEffect(), removeEffect()).

Что важно

Связи one-to-many отображают состав сущности.

Модель универсальна и подходит под разные игровые системы.

В таком виде её удобно реализовывать в SQLite и в JSON-файлах.

Зачем нужна диаграмма

Это самый нижний уровень архитектуры — он демонстрирует:

структуру данных,

основные связи,

реальные инженерные решения.

В дипломной работе этот уровень даёт наглядную иллюстрацию внутреннего устройства модели.

6. Итоговое представление

В совокупности, все четыре диаграммы дают последовательную и понятную картину архитектуры приложения:

Уровень C4	На что отвечает	Что показывает
Context	Что за система	Пользователи, роли, общий контур
Container	Из чего состоит	Интерфейс, логика, хранилище
Component	Как устроены части	Модули, связи, ответственность
Code	Как устроены данные	Классы, атрибуты, методы

Такой набор диаграмм представляет архитектуру полно и достаточно формально, чтобы использовать в дипломной части «Архитектура системы», а также в GitHub как часть технической документации.
