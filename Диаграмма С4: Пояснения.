# make_architecture_pdf.py
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm


TEXT = """
Архитектурная модель системы «НРИ-Помощник (офлайн)»
Документация к C4-диаграммам
Автор: Павлов Михаил

1. Общая логика подхода C4

Архитектура приложения описана через модель C4, которая позволяет последовательно раскрывать систему: от высокого уровня (кто взаимодействует с приложением) до уровня кода (модели данных и классы).

Каждый уровень отвечает на свой вопрос:

Context — «Что это за система?» — область применения и участники.
Container — «Как система устроена?» — основные подсистемы и связи.
Component — «Из чего состоят подсистемы?» — внутренняя логика и модули.
Code — «Как представлены данные?» — классы, поля, сущности.

Такой подход делает архитектуру стройной и понятной.

2. Контекстная диаграмма (Context)

Файл: context.puml.

Контекстная диаграмма показывает общую рамку и объясняет, кто и как взаимодействует с системой.

Участники:
— Ведущий (Мастер) — управляет сессией, вводит данные, формирует итоги.
— Игрок — передаёт параметры персонажа, получает результаты через мастера.
— Система «НРИ-Помощник (офлайн)» — автономное приложение с логикой расчётов, журналом и экспортом данных.

Особенности:
— полное отсутствие сетевого взаимодействия;
— игроки взаимодействуют с приложением через ведущего;
— система — центральный инструмент всей игровой логики.

Задача контекстного уровня — обозначить рамки системы и участников игрового процесса.

3. Контейнерная диаграмма (Container)

Файл: container.puml.

На этом уровне фиксируются крупные подсистемы приложения — так называемые “контейнеры”.

Состав контейнеров:

1) UI (пользовательский интерфейс)
Формы персонажей, панели управления сценами, просмотр журнала и отчётов.

2) Core (ядро логики)
Обработка бросков, механика боёв, управление состояниями, ведение журнала.

3) Local Storage (локальное хранилище)
SQLite или файловое хранилище; персонажи, события, сессии, резервные копии.

Связи:
— UI → Core — команды и действия;
— Core ↔ Storage — чтение и запись данных;
— Ведущий ↔ UI — взаимодействие с системой.

Задача контейнерного уровня — показать архитектурный “скелет” приложения и структуру подсистем.

4. Компонентная диаграмма ядра (Component)

Файл: component-core.puml.

Этот уровень раскрывает внутреннее устройство контейнера Core — главной логической части системы.

Компоненты ядра:
— CharacterEditor — редактирование персонажей, навыков, инвентаря;
— DiceEngine — броски кубиков, модификаторы, формулы;
— CombatEngine — боевые расчёты: инициатива, урон, состояния;
— Journal — журнал действий, временные метки;
— StorageService — работа с локальными данными;
— Reports — формирование итогов и отчётов (PDF/CSV).

Основные связи между компонентами:
— DiceEngine передаёт результаты CombatEngine;
— CharacterEditor и CombatEngine записывают события в Journal;
— Reports собирает данные через StorageService.

Задача компонентного уровня — структурировать внутреннюю механику ядра, разграничив функциональные блоки и их ответственность.

5. Диаграмма кода (Code)

Файл: code-character.puml.

Низкоуровневое представление структуры данных. Здесь приводятся сущности, которыми реально оперирует приложение.

Основные классы:

Character:
— id;
— имя персонажа;
— атрибуты (силы, ловкости и т.д.);
— навыки;
— список эффектов;
— инвентарь;
— методы применения и снятия эффектов.

Effect:
— название;
— модификаторы атрибутов;
— длительность.

Item:
— id;
— краткое описание;
— дополнительные свойства.

Связи:
Персонаж содержит несколько Item и Effect — это составные элементы, связанные с жизненным циклом персонажа.

Задача уровня Code — формализовать модель данных для устойчивой реализации приложения и дальнейшего развития проекта.

6. Итоговое обобщение уровней

Все диаграммы вместе дают стройную архитектурную картину.

Контекстный уровень показывает внешние роли и границы системы и используется для анализа предметной области.
Контейнерный уровень описывает основную структуру и подсистемы и применяется при архитектурном проектировании.
Компонентный уровень фиксирует внутренние блоки логики и удобен при планировании разработки и разделении задач.
Уровень кода (Code) задаёт классы данных и связи, непосредственно используемые в программной реализации.

Такой набор диаграмм помогает документировать архитектуру для репозитория, удерживать структуру проекта в порядке, объяснять систему в дипломной работе и планировать её развитие.

7. Как работать с файлами .puml

1. Скачайте репозиторий C4-PlantUML с GitHub.
2. Положите его рядом с файлами диаграмм.
3. Проверьте путь вида:
   !include C4-PlantUML/C4_Context.puml
4. Откройте .puml в VS Code.
5. Нажмите Alt + D, чтобы увидеть диаграмму.
6. При необходимости экспортируйте в PNG или SVG для дальнейшего использования.
"""


def build_pdf(path: str = "architecture_nri_helper.pdf"):
    styles = getSampleStyleSheet()
    base = styles["Normal"]
    base.leading = 14

    title_style = ParagraphStyle(
        "Title",
        parent=styles["Heading1"],
        alignment=1,
        spaceAfter=12,
    )

    story = []

    lines = TEXT.strip().split("\n")
    # Заголовок
    story.append(Paragraph(lines[0], title_style))
    story.append(Paragraph(lines[1], base))
    story.append(Paragraph(lines[2], base))
    story.append(Spacer(1, 12))

    # Остальной текст
    current_par = []
    for line in lines[4:]:
        if line.strip() == "":
            if current_par:
                story.append(Paragraph(" ".join(current_par), base))
                story.append(Spacer(1, 6))
                current_par = []
        else:
            current_par.append(line.strip())

    if current_par:
        story.append(Paragraph(" ".join(current_par), base))

    doc = SimpleDocTemplate(
        path,
        pagesize=A4,
        leftMargin=20 * mm,
        rightMargin=20 * mm,
        topMargin=20 * mm,
        bottomMargin=20 * mm,
    )
    doc.build(story)
    print(f"PDF создан: {path}")


if __name__ == "__main__":
    build_pdf()
